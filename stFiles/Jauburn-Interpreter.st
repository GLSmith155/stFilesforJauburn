Object subclass: #JbSamplePrograms	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Interpreter-SamplePrograms'!!JbSamplePrograms commentStamp: '' prior: 0!Just a place to house a few sample programs!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JbSamplePrograms class	instanceVariableNames: ''!!JbSamplePrograms class methodsFor: 'sample programs'!noFunctions	"self run: self noFunctions"	^ 'var x = 4;var y = 10 * x + 2;print y;'! !!JbSamplePrograms class methodsFor: 'sample programs'!assignAndPrint	"self run: self assignAndPrint"	^ 'var x = 19;var y = 32 * ( x + 5 ) * x;print x;print y;print 5*y;'! !!JbSamplePrograms class methodsFor: 'utilities'!run: aString	"Look at sample programs for examples of using this method."	^ JbInterpreter new run: aString! !Object subclass: #JbEnvironment	instanceVariableNames: 'bindings outerEnvironment'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbEnvironment commentStamp: '' prior: 0!This is a copy of the Phsyche PEnvironment class!!JbEnvironment methodsFor: 'accessing'!outerEnvironment: anEnvironment	outerEnvironment := anEnvironment! !!JbEnvironment methodsFor: 'accessing'!at: aKey	| value |	value := bindings at: aKey ifAbsent: [ nil ].	^ value		  ifNil: [ 			  outerEnvironment				  ifNil: [ bindings at: aKey ]				  ifNotNil: [ outerEnvironment at: aKey ] ]		  ifNotNil: [ :v | v ]! !!JbEnvironment methodsFor: 'accessing'!initialize 	super initialize .	bindings := Dictionary new.! !!JbEnvironment methodsFor: 'accessing'!lookupAt: aKey put: aValue	"Change the value of the binding whose key is aKey, but looking in the complete ancestor chain.	If the binding does not exist, it raises an error to indicate that we should define it first."	| found |	found := bindings at: aKey ifAbsent: nil.	found		ifNil: [ 			outerEnvironment				ifNotNil: [ outerEnvironment lookupAt: aKey put: aValue ]				ifNil: [ 				KeyNotFound signal: aKey , ' not found in the environment' ] ]		ifNotNil: [ self at: aKey put: aValue ]! !!JbEnvironment methodsFor: 'accessing'!at: aKey put: aValue	bindings at: aKey put: aValue! !!JbEnvironment methodsFor: 'accessing'!includesKey: aKey	^bindings includesKey: aKey! !!JbEnvironment methodsFor: 'accessing'!variableNames	^ bindings keys! !Object subclass: #JbFunction	instanceVariableNames: 'body parameters environment'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbFunction commentStamp: '' prior: 0!I am the value that results from evaluating a function.  My i-vars	parameters -- collection holding names of my parameters 	environment -- a JbEnvironment instance holding the environment in effect when I was created (closures!!)	body -- an AST node for the body of this function!!JbFunction methodsFor: 'accessing'!parameters	^ parameters! !!JbFunction methodsFor: 'accessing'!environment	^ environment! !!JbFunction methodsFor: 'accessing'!body	^ body! !!JbFunction methodsFor: 'accessing'!environment: anObject	environment := anObject! !!JbFunction methodsFor: 'accessing'!body: anObject	body := anObject! !!JbFunction methodsFor: 'accessing'!parameters: anObject	parameters := anObject! !!JbFunction methodsFor: 'api'!call: arguments in: callEnvironment	"You need to implement this method!!  arguments will contain the arguments to pass to this function and callEnvironment will contain the environment in place when this function was called."		self shouldBeImplemented ! !Object subclass: #JbInterpreter	instanceVariableNames: 'environment'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbInterpreter commentStamp: '' prior: 0!I am an interpreter for programs written in the Jauburn language.  My principle API methods are:	interpret: anAST -- given an abstract syntax tree, interpret it	run: aString -- parse and interpret the supplied string!!JbInterpreter methodsFor: 'api'!interpret: programString	| ast |	ast := self parse: programString.	self interpretAst: ast! !!JbInterpreter methodsFor: 'api'!parse: programString	| parser |	parser := JbParser new.	^(parser parse: programString)! !!JbInterpreter methodsFor: 'api'!run: programString	"Just an alias for #interpret:"	self interpret: programString! !!JbInterpreter methodsFor: 'api'!interpretAst: ast	^ ast executeIn: environment! !!JbInterpreter methodsFor: 'initialization'!initialize 	super initialize.	environment := JbEnvironment new! !!JbInterpreter methodsFor: 'accessing'!environment 	^environment! !PackageManifest subclass: #ManifestJauburnInterpreter	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Interpreter-Manifest'!!ManifestJauburnInterpreter commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.633 pm'!!JbVariableDeclarationStatementNode methodsFor: '*Jauburn-Interpreter'!executeIn: environment	environment at: self identifier put: (self expression evaluateIn: environment)! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.634 pm'!!JbIdentifierExpressionNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment 	^environment at: self identifier! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.635 pm'!!JbConstantExpressionNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	^self value! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.635 pm'!!JbAssignmentStatementNode methodsFor: '*Jauburn-Interpreter'!executeIn: environment	environment		lookupAt: self identifier		put: (self expression evaluateIn: environment)! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.636 pm'!!JbNumericComparisonNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	| lhsValue rhsValue |	lhsValue := self lhs evaluateIn: environment.	rhsValue := self rhs evaluateIn: environment.	self operator = '<' ifTrue: [ ^ lhsValue < rhsValue ].	self operator = '>' ifTrue: [ ^ lhsValue > rhsValue ].	self operator = '<=' ifTrue: [ ^ lhsValue <= rhsValue ].	self operator = '>=' ifTrue: [ ^ lhsValue >= rhsValue ].	self operator = '==' ifTrue: [ ^ lhsValue = rhsValue ].	self operator = '!!=' ifTrue: [ ^ lhsValue ~= rhsValue ].	self error: 'Unrecognized operator: ' , self operator asString! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.636 pm'!!JbArity2OperatorNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	| lhsValue rhsValue |	lhsValue := self lhs evaluateIn: environment.	rhsValue := self rhs evaluateIn: environment.	self operator = $*		ifTrue: [ ^lhsValue * rhsValue ].	self operator = $+		ifTrue: [ ^lhsValue + rhsValue ]! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.637 pm'!!JbPrintStatementNode methodsFor: '*Jauburn-Interpreter'!executeIn: anEnvironment	| value |	value := expression evaluateIn: anEnvironment.	Transcript		show: value;		cr! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.637 pm'!!JbProgramNode methodsFor: '*Jauburn-Interpreter'!executeIn: environment	statements do: [ :each | each executeIn: environment ]! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.637 pm'!!JbAbstractSyntaxTreeNode methodsFor: '*Jauburn-Interpreter'!executeIn: aContext	self error: 'Statements must override this method.  Expressions _must not_ override this method since it is an error to send #executeIn: to an expression.'! !'From Pharo10.0.0 of 5 December 2022 [Build information: Pharo-10.0.0+build.536.sha.2314c3f457171dcde477ff6575b578835f1fd519 (64 Bit)] on 4 March 2023 at 2:02:22.638 pm'!!JbAbstractSyntaxTreeNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: aContext	self error:		'Expressions must override this method.  Statements _must not_ override this method since it is an error to send #evaluateIn: to a statement.'! !